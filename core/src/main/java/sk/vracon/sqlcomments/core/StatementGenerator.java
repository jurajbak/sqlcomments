/*
 * Copyright 2014 Vracon s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package sk.vracon.sqlcomments.core;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Collection;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;

import javax.script.Bindings;
import javax.script.ScriptException;
import javax.script.SimpleBindings;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import sk.vracon.sqlcomments.core.dialect.DatabaseDialect;

/**
 * Utility class to process statement objects and generate JPA and JDBC statements.
 * <p>
 * To log generated statement string, setup logging for this class to debug level.
 * </p>
 */
public class StatementGenerator {

    private static Logger logger = LoggerFactory.getLogger(StatementGenerator.class);

    private DatabaseDialect dialect;

    /**
     * Creates prepared statement for given JDBC connection and parameters.
     * 
     * @see Connection#prepareStatement(String, int)
     * 
     * @param connection
     *            JDBC connection
     * @param statement
     *            statement to process
     * @param parameters
     *            parameters to use
     * @param acceptNullParameters
     *            names of parameters accepting null values
     * @param offset
     *            result set offset
     * @param limit
     *            result set limit
     * @param withKeys
     *            if true prepared statement will return auto-generated keys
     */
    public PreparedStatement createPreparedStatement(Connection connection, Statement statement, Map<String, Object> parameters,
            Set<String> acceptNullParameters, Long offset, Long limit, boolean withKeys) throws StatementException {
        return createPreparedStatement(connection, statement, parameters, acceptNullParameters, offset, limit, withKeys ? new String[0] : null);
    }

    /**
     * Creates prepared statement for given JDBC connection and parameters.
     * 
     * @see Connection#prepareStatement(String, String[])
     * 
     * @param connection
     *            JDBC connection
     * @param statement
     *            statement to process
     * @param parameters
     *            parameters to use
     * @param acceptNullParameters
     *            names of parameters accepting null values
     * @param offset
     *            result set offset
     * @param limit
     *            result set limit
     * @param keysToGenerate
     *            list of keys to generate
     */
    public PreparedStatement createPreparedStatement(Connection connection, Statement statement, Map<String, Object> parameters,
            Set<String> acceptNullParameters, Long offset, Long limit, String[] keysToGenerate) throws StatementException {

        if (connection == null) {
            throw new IllegalArgumentException("Connection must be set.");
        }
        if (statement == null) {
            throw new IllegalArgumentException("Statement must be set.");
        }

        // Replace parameter names with question marks to conform JDBC
        List<Object> jdbcParams = new LinkedList<Object>();
        String jdbcSql = generateJdbcStatement(statement, parameters, acceptNullParameters, jdbcParams, offset, limit);

        logger.debug(jdbcSql);

        // Generate SQL statement
        try {
            // Create java.sql prepared statement
            PreparedStatement jdbcStatement = null;
            if (keysToGenerate != null && keysToGenerate.length == 0) {
                // Auto generate keys
                int autoGeneratedKeys = java.sql.Statement.RETURN_GENERATED_KEYS;
                jdbcStatement = connection.prepareStatement(jdbcSql, autoGeneratedKeys);
            } else if (keysToGenerate != null && keysToGenerate.length > 0) {
                // Return specified keys
                jdbcStatement = connection.prepareStatement(jdbcSql, keysToGenerate);
            } else {
                // Use default
                jdbcStatement = connection.prepareStatement(jdbcSql);
            }

            int i = 1;
            for (Object param : jdbcParams) {
                if (param instanceof Date) {
                    // java.util.Date conversion
                    jdbcStatement.setObject(i, new Timestamp(((Date) param).getTime()));
                } else {
                    jdbcStatement.setObject(i, param);
                }
                i++;
            }

            return jdbcStatement;
        }
        catch (SQLException e) {
            throw new StatementException("SQL error: " + e.getMessage(), e);
        }
    }

    /**
     * Creates callable statement for given JDBC connection and parameters.
     * 
     * @param connection
     *            JDBC connection
     * @param statement
     *            statement to process
     * @param parameters
     *            parameters to use
     * @param acceptNullParameters
     *            names of parameters accepting null values
     */
    public CallableStatement createPreparedCall(Connection connection, Statement statement, Map<String, Object> parameters, Set<String> acceptNullParameters)
            throws StatementException {
        if (connection == null) {
            throw new IllegalArgumentException("Connection must be set.");
        }
        if (statement == null) {
            throw new IllegalArgumentException("Statement must be set.");
        }

        // Replace parameter names with question marks to conform JDBC
        List<Object> jdbcParams = new LinkedList<Object>();
        String jdbcSql = generateJdbcStatement(statement, parameters, acceptNullParameters, jdbcParams, null, null);

        logger.debug(jdbcSql);

        // Generate SQL statement
        try {
            // Create java.sql prepared statement
            CallableStatement jdbcStatement = connection.prepareCall(jdbcSql);

            int i = 1;
            for (Object param : jdbcParams) {
                if (param instanceof Date) {
                    // java.util.Date conversion
                    jdbcStatement.setObject(i, new Timestamp(((Date) param).getTime()));
                } else {
                    jdbcStatement.setObject(i, param);
                }
                i++;
            }

            return jdbcStatement;
        }
        catch (SQLException e) {
            throw new StatementException("SQL error: " + e.getMessage(), e);
        }
    }

    /**
     * Creates JDBC-like statement string.
     * <p>
     * This method is useful when standard {@link #createPreparedCall(Connection, Statement, Map, Set)} and
     * {@link #createPreparedStatement(Connection, Statement, Map, Set, boolean)} are not enough. It returns generated
     * statement string with replaced SQL parameters by '?' and parameter values are put into jdbcParams list.
     * </p>
     * 
     * @param statement
     *            statement to process
     * @param parameters
     *            parameters to use
     * @param acceptNullParameters
     *            names of parameters accepting null values
     * @param jdbcParams
     *            list where will be generated JDBC parameters
     * @param offset
     *            result set offset
     * @param limit
     *            result set limit
     * @return generated JDBC-like statement
     * 
     * @see #generateStatement(Statement, Map, Set)
     */
    public String generateJdbcStatement(Statement statement, Map<String, Object> parameters, Set<String> acceptNullParameters, List<Object> jdbcParams,
            Long offset, Long limit) {
        String sql = null;
        try {
            sql = generateStatement(statement, parameters, acceptNullParameters, offset, limit);
        }
        catch (ScriptException e) {
            throw new StatementException("Error while generating SQL: " + e.getMessage(), e);
        }

        String jdbcSql = sql;

        if (parameters != null && parameters.size() > 0) {
            // Replace placeholders with ?
            StringBuilder jdbcSqlBuilder = new StringBuilder();
            Matcher matcher = Constants.SQL_PARAM_PATTERN.matcher(sql);
            int lastEnd = 0;
            while (matcher.find()) {
                String placeholderName = matcher.group(1);
                Object placeholderValue = parameters.get(placeholderName);

                jdbcSqlBuilder.append(sql.substring(lastEnd, matcher.start()));

                if (placeholderValue instanceof Collection) {
                    // Placeholder is a collection - it should be replaced by a list of values
                    @SuppressWarnings("rawtypes")
                    Collection values = (Collection) placeholderValue;
                    boolean addComma = false;
                    for (Object value : values) {
                        if (addComma) {
                            jdbcSqlBuilder.append(",");
                        } else {
                            addComma = true;
                        }
                        jdbcSqlBuilder.append("?");
                        jdbcParams.add(value);
                    }
                } else {
                    // Simple value placeholder
                    jdbcSqlBuilder.append("?");
                    jdbcParams.add(placeholderValue);
                }

                lastEnd = matcher.end();
            }
            jdbcSqlBuilder.append(sql.substring(lastEnd));

            jdbcSql = jdbcSqlBuilder.toString();
        }

        return jdbcSql;
    }

    /**
     * Creates statement string.
     * <p>
     * Statement is processed row by row. Row is omitted if:
     * <ol>
     * <li>Parameters in SQL is missing or has null value and is not mentioned in acceptNullValues.</li>
     * <li>Control script didn't return 'true'.</li>
     * </ol>
     * </p>
     * <p>
     * All replacement parameters are replaced by value. If there's no parameter with appropriate name, replacement is
     * left without change.
     * </p>
     * <p>
     * This method is could be used for generating JPA statements.
     * </p>
     * 
     * @param statement
     *            statement to process
     * @param parameters
     *            parameters to use
     * @param acceptNullParameters
     *            names of parameters accepting null values
     * @param offset
     *            result set offset
     * @param limit
     *            result set limit
     * @return constructed statement string without replaced SQL parameters
     */
    public String generateStatement(Statement statement, Map<String, Object> parameters, Set<String> acceptNullParameters, Long offset, Long limit)
            throws ScriptException {

        // Construct statement string according to given settings
        StringBuilder result = new StringBuilder();

        ROW_LOOP:
        for (RowInfo row : statement.getRows()) {
            // Check if all SQL parameters have non-null values
            if (row.getSqlParameters() != null) {
                for (String param : row.getSqlParameters()) {
                    if (parameters == null || parameters.get(param) == null) {
                        if (acceptNullParameters == null || !acceptNullParameters.contains(param)) {
                            // Parameter was not set, nor it is not accepting null values - skip line
                            continue ROW_LOOP;
                        }
                    }
                }
            }

            // Evaluate script
            if (row.getScript() != null) {
                // Prepare parameters
                Bindings bindings = null;
                if (parameters == null) {
                    bindings = new SimpleBindings();
                } else {
                    bindings = new SimpleBindings(parameters);
                }

                // Evaluate script
                Object rowResult = row.getScript().eval(bindings);

                if (rowResult == null || !(rowResult instanceof Boolean) || !((Boolean) rowResult)) {
                    // Script didn't return boolean true - skip line
                    continue;
                }
            }

            // All passed = add line to result
            String line = replaceParameters(parameters, row);
            result.append(line);
            result.append("\n");
        }

        if (offset == null && limit == null) {
            return result.toString();
        } else {
            return dialect.generateSQLWithOffsetAndLimit(result.toString(), offset, limit);
        }
    }

    private String replaceParameters(Map<String, Object> parameters, RowInfo row) {
        String line = row.getLine();
        if (row.getReplacementParameters() != null) {
            for (String replacement : row.getReplacementParameters()) {
                Object value = parameters.get(replacement);
                if (value != null) {
                    line = line.replace(Constants.REPLACEMENT_START_TOKEN + replacement + Constants.REPLACEMENT_END_TOKEN, value.toString());
                }
            }
        }
        return line;
    }

    /**
     * Sets database dialect to use.
     * 
     * @param dialect
     *            database dialect
     */
    public void setDialect(DatabaseDialect dialect) {
        this.dialect = dialect;
    }
}
